#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************   Forward Declarations    ********************/

class Program;
class Decl;
class Predicate;
class Prg;
class Exec;
class Caus;
class Init;
class Preds;
class Pred;
class ListPredicate;
class ListIdent;
class ListDecl;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitProgram(Program *p) = 0;
  virtual void visitDecl(Decl *p) = 0;
  virtual void visitPredicate(Predicate *p) = 0;
  virtual void visitPrg(Prg *p) = 0;
  virtual void visitExec(Exec *p) = 0;
  virtual void visitCaus(Caus *p) = 0;
  virtual void visitInit(Init *p) = 0;
  virtual void visitPreds(Preds *p) = 0;
  virtual void visitPred(Pred *p) = 0;
  virtual void visitListPredicate(ListPredicate *p) = 0;
  virtual void visitListIdent(ListIdent *p) = 0;
  virtual void visitListDecl(ListDecl *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Program : public Visitable
{
public:
  virtual Program *clone() const = 0;

};

class Decl : public Visitable
{
public:
  virtual Decl *clone() const = 0;

};

class Predicate : public Visitable
{
public:
  virtual Predicate *clone() const = 0;

};



class Prg : public Program
{
public:
  ListDecl *listdecl_;

  Prg(const Prg &);
  Prg &operator=(const Prg &);
  Prg(ListDecl *p1);
  ~Prg();
  virtual void accept(Visitor *v);
  virtual Prg *clone() const;
  void swap(Prg &);
};

class Exec : public Decl
{
public:
  Predicate *predicate_;
  ListPredicate *listpredicate_;

  Exec(const Exec &);
  Exec &operator=(const Exec &);
  Exec(Predicate *p1, ListPredicate *p2);
  ~Exec();
  virtual void accept(Visitor *v);
  virtual Exec *clone() const;
  void swap(Exec &);
};

class Caus : public Decl
{
public:
  Predicate *predicate_;
  ListPredicate *listpredicate_;

  Caus(const Caus &);
  Caus &operator=(const Caus &);
  Caus(Predicate *p1, ListPredicate *p2);
  ~Caus();
  virtual void accept(Visitor *v);
  virtual Caus *clone() const;
  void swap(Caus &);
};

class Init : public Decl
{
public:
  Predicate *predicate_;

  Init(const Init &);
  Init &operator=(const Init &);
  Init(Predicate *p1);
  ~Init();
  virtual void accept(Visitor *v);
  virtual Init *clone() const;
  void swap(Init &);
};

class Preds : public Predicate
{
public:
  Ident ident_;
  ListIdent *listident_;

  Preds(const Preds &);
  Preds &operator=(const Preds &);
  Preds(Ident p1, ListIdent *p2);
  ~Preds();
  virtual void accept(Visitor *v);
  virtual Preds *clone() const;
  void swap(Preds &);
};

class Pred : public Predicate
{
public:
  Ident ident_;

  Pred(const Pred &);
  Pred &operator=(const Pred &);
  Pred(Ident p1);
  ~Pred();
  virtual void accept(Visitor *v);
  virtual Pred *clone() const;
  void swap(Pred &);
};



class ListPredicate : public Visitable, public std::vector<Predicate*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListPredicate *clone() const;
};

class ListIdent : public Visitable, public std::vector<Ident>
{
public:
  virtual void accept(Visitor *v);
  virtual ListIdent *clone() const;
};

class ListDecl : public Visitable, public std::vector<Decl*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListDecl *clone() const;
};



#endif
