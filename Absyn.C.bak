//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"

/********************   Prg    ********************/
Prg::Prg(ListDecl *p1)
{
  listdecl_ = p1;

}

Prg::Prg(const Prg & other)
{
  listdecl_ = other.listdecl_->clone();

}

Prg &Prg::operator=(const Prg & other)
{
  Prg tmp(other);
  swap(tmp);
  return *this;
}

void Prg::swap(Prg & other)
{
  std::swap(listdecl_, other.listdecl_);

}

Prg::~Prg()
{
  delete(listdecl_);

}

void Prg::accept(Visitor *v)
{
  v->visitPrg(this);
}

Prg *Prg::clone() const
{
  return new Prg(*this);
}



/********************   Exec    ********************/
Exec::Exec(Action *p1, ListLiteral *p2)
{
  action_ = p1;
  listliteral_ = p2;

}

Exec::Exec(const Exec & other)
{
  action_ = other.action_->clone();
  listliteral_ = other.listliteral_->clone();

}

Exec &Exec::operator=(const Exec & other)
{
  Exec tmp(other);
  swap(tmp);
  return *this;
}

void Exec::swap(Exec & other)
{
  std::swap(action_, other.action_);
  std::swap(listliteral_, other.listliteral_);

}

Exec::~Exec()
{
  delete(action_);
  delete(listliteral_);

}

void Exec::accept(Visitor *v)
{
  v->visitExec(this);
}

Exec *Exec::clone() const
{
  return new Exec(*this);
}



/********************   Caus    ********************/
Caus::Caus(Action *p1, ListLiteral *p2)
{
  action_ = p1;
  listliteral_ = p2;

}

Caus::Caus(const Caus & other)
{
  action_ = other.action_->clone();
  listliteral_ = other.listliteral_->clone();

}

Caus &Caus::operator=(const Caus & other)
{
  Caus tmp(other);
  swap(tmp);
  return *this;
}

void Caus::swap(Caus & other)
{
  std::swap(action_, other.action_);
  std::swap(listliteral_, other.listliteral_);

}

Caus::~Caus()
{
  delete(action_);
  delete(listliteral_);

}

void Caus::accept(Visitor *v)
{
  v->visitCaus(this);
}

Caus *Caus::clone() const
{
  return new Caus(*this);
}



/********************   CausCond    ********************/
CausCond::CausCond(Action *p1, ListLiteral *p2, ListLiteral *p3)
{
  action_ = p1;
  listliteral_1 = p2;
  listliteral_2 = p3;

}

CausCond::CausCond(const CausCond & other)
{
  action_ = other.action_->clone();
  listliteral_1 = other.listliteral_1->clone();
  listliteral_2 = other.listliteral_2->clone();

}

CausCond &CausCond::operator=(const CausCond & other)
{
  CausCond tmp(other);
  swap(tmp);
  return *this;
}

void CausCond::swap(CausCond & other)
{
  std::swap(action_, other.action_);
  std::swap(listliteral_1, other.listliteral_1);
  std::swap(listliteral_2, other.listliteral_2);

}

CausCond::~CausCond()
{
  delete(action_);
  delete(listliteral_1);
  delete(listliteral_2);

}

void CausCond::accept(Visitor *v)
{
  v->visitCausCond(this);
}

CausCond *CausCond::clone() const
{
  return new CausCond(*this);
}



/********************   Init    ********************/
Init::Init(Literal *p1)
{
  literal_ = p1;

}

Init::Init(const Init & other)
{
  literal_ = other.literal_->clone();

}

Init &Init::operator=(const Init & other)
{
  Init tmp(other);
  swap(tmp);
  return *this;
}

void Init::swap(Init & other)
{
  std::swap(literal_, other.literal_);

}

Init::~Init()
{
  delete(literal_);

}

void Init::accept(Visitor *v)
{
  v->visitInit(this);
}

Init *Init::clone() const
{
  return new Init(*this);
}



/********************   Final    ********************/
Final::Final(Literal *p1)
{
  literal_ = p1;

}

Final::Final(const Final & other)
{
  literal_ = other.literal_->clone();

}

Final &Final::operator=(const Final & other)
{
  Final tmp(other);
  swap(tmp);
  return *this;
}

void Final::swap(Final & other)
{
  std::swap(literal_, other.literal_);

}

Final::~Final()
{
  delete(literal_);

}

void Final::accept(Visitor *v)
{
  v->visitFinal(this);
}

Final *Final::clone() const
{
  return new Final(*this);
}



/********************   Preds    ********************/
Preds::Preds(Ident p1, ListIdent *p2)
{
  ident_ = p1;
  listident_ = p2;

}

Preds::Preds(const Preds & other)
{
  ident_ = other.ident_;
  listident_ = other.listident_->clone();

}

Preds &Preds::operator=(const Preds & other)
{
  Preds tmp(other);
  swap(tmp);
  return *this;
}

void Preds::swap(Preds & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listident_, other.listident_);

}

Preds::~Preds()
{
  delete(listident_);

}

void Preds::accept(Visitor *v)
{
  v->visitPreds(this);
}

Preds *Preds::clone() const
{
  return new Preds(*this);
}



/********************   Pred    ********************/
Pred::Pred(Ident p1)
{
  ident_ = p1;

}

Pred::Pred(const Pred & other)
{
  ident_ = other.ident_;

}

Pred &Pred::operator=(const Pred & other)
{
  Pred tmp(other);
  swap(tmp);
  return *this;
}

void Pred::swap(Pred & other)
{
  std::swap(ident_, other.ident_);

}

Pred::~Pred()
{

}

void Pred::accept(Visitor *v)
{
  v->visitPred(this);
}

Pred *Pred::clone() const
{
  return new Pred(*this);
}



/********************   LitN    ********************/
LitN::LitN(Predicate *p1)
{
  predicate_ = p1;

}

LitN::LitN(const LitN & other)
{
  predicate_ = other.predicate_->clone();

}

LitN &LitN::operator=(const LitN & other)
{
  LitN tmp(other);
  swap(tmp);
  return *this;
}

void LitN::swap(LitN & other)
{
  std::swap(predicate_, other.predicate_);

}

LitN::~LitN()
{
  delete(predicate_);

}

void LitN::accept(Visitor *v)
{
  v->visitLitN(this);
}

LitN *LitN::clone() const
{
  return new LitN(*this);
}



/********************   Lit    ********************/
Lit::Lit(Predicate *p1)
{
  predicate_ = p1;

}

Lit::Lit(const Lit & other)
{
  predicate_ = other.predicate_->clone();

}

Lit &Lit::operator=(const Lit & other)
{
  Lit tmp(other);
  swap(tmp);
  return *this;
}

void Lit::swap(Lit & other)
{
  std::swap(predicate_, other.predicate_);

}

Lit::~Lit()
{
  delete(predicate_);

}

void Lit::accept(Visitor *v)
{
  v->visitLit(this);
}

Lit *Lit::clone() const
{
  return new Lit(*this);
}



/********************   Acts    ********************/
Acts::Acts(Ident p1, ListIdent *p2)
{
  ident_ = p1;
  listident_ = p2;

}

Acts::Acts(const Acts & other)
{
  ident_ = other.ident_;
  listident_ = other.listident_->clone();

}

Acts &Acts::operator=(const Acts & other)
{
  Acts tmp(other);
  swap(tmp);
  return *this;
}

void Acts::swap(Acts & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listident_, other.listident_);

}

Acts::~Acts()
{
  delete(listident_);

}

void Acts::accept(Visitor *v)
{
  v->visitActs(this);
}

Acts *Acts::clone() const
{
  return new Acts(*this);
}



/********************   Act    ********************/
Act::Act(Ident p1)
{
  ident_ = p1;

}

Act::Act(const Act & other)
{
  ident_ = other.ident_;

}

Act &Act::operator=(const Act & other)
{
  Act tmp(other);
  swap(tmp);
  return *this;
}

void Act::swap(Act & other)
{
  std::swap(ident_, other.ident_);

}

Act::~Act()
{

}

void Act::accept(Visitor *v)
{
  v->visitAct(this);
}

Act *Act::clone() const
{
  return new Act(*this);
}




/********************   ListLiteral    ********************/

void ListLiteral::accept(Visitor *v)
{
  v->visitListLiteral(this);
}


ListLiteral *ListLiteral::clone() const
{
  return new ListLiteral(*this);
}


/********************   ListIdent    ********************/

void ListIdent::accept(Visitor *v)
{
  v->visitListIdent(this);
}


ListIdent *ListIdent::clone() const
{
  return new ListIdent(*this);
}


/********************   ListDecl    ********************/

void ListDecl::accept(Visitor *v)
{
  v->visitListDecl(this);
}


ListDecl *ListDecl::clone() const
{
  return new ListDecl(*this);
}




