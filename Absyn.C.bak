//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"

/********************   Prg    ********************/
Prg::Prg(ListDecl *p1)
{
  listdecl_ = p1;

}

Prg::Prg(const Prg & other)
{
  listdecl_ = other.listdecl_->clone();

}

Prg &Prg::operator=(const Prg & other)
{
  Prg tmp(other);
  swap(tmp);
  return *this;
}

void Prg::swap(Prg & other)
{
  std::swap(listdecl_, other.listdecl_);

}

Prg::~Prg()
{
  delete(listdecl_);

}

void Prg::accept(Visitor *v)
{
  v->visitPrg(this);
}

Prg *Prg::clone() const
{
  return new Prg(*this);
}



/********************   Exec    ********************/
Exec::Exec(Predicate *p1, ListPredicate *p2)
{
  predicate_ = p1;
  listpredicate_ = p2;

}

Exec::Exec(const Exec & other)
{
  predicate_ = other.predicate_->clone();
  listpredicate_ = other.listpredicate_->clone();

}

Exec &Exec::operator=(const Exec & other)
{
  Exec tmp(other);
  swap(tmp);
  return *this;
}

void Exec::swap(Exec & other)
{
  std::swap(predicate_, other.predicate_);
  std::swap(listpredicate_, other.listpredicate_);

}

Exec::~Exec()
{
  delete(predicate_);
  delete(listpredicate_);

}

void Exec::accept(Visitor *v)
{
  v->visitExec(this);
}

Exec *Exec::clone() const
{
  return new Exec(*this);
}



/********************   Caus    ********************/
Caus::Caus(Predicate *p1, ListPredicate *p2)
{
  predicate_ = p1;
  listpredicate_ = p2;

}

Caus::Caus(const Caus & other)
{
  predicate_ = other.predicate_->clone();
  listpredicate_ = other.listpredicate_->clone();

}

Caus &Caus::operator=(const Caus & other)
{
  Caus tmp(other);
  swap(tmp);
  return *this;
}

void Caus::swap(Caus & other)
{
  std::swap(predicate_, other.predicate_);
  std::swap(listpredicate_, other.listpredicate_);

}

Caus::~Caus()
{
  delete(predicate_);
  delete(listpredicate_);

}

void Caus::accept(Visitor *v)
{
  v->visitCaus(this);
}

Caus *Caus::clone() const
{
  return new Caus(*this);
}



/********************   Init    ********************/
Init::Init(Predicate *p1)
{
  predicate_ = p1;

}

Init::Init(const Init & other)
{
  predicate_ = other.predicate_->clone();

}

Init &Init::operator=(const Init & other)
{
  Init tmp(other);
  swap(tmp);
  return *this;
}

void Init::swap(Init & other)
{
  std::swap(predicate_, other.predicate_);

}

Init::~Init()
{
  delete(predicate_);

}

void Init::accept(Visitor *v)
{
  v->visitInit(this);
}

Init *Init::clone() const
{
  return new Init(*this);
}



/********************   Preds    ********************/
Preds::Preds(Ident p1, ListIdent *p2)
{
  ident_ = p1;
  listident_ = p2;

}

Preds::Preds(const Preds & other)
{
  ident_ = other.ident_;
  listident_ = other.listident_->clone();

}

Preds &Preds::operator=(const Preds & other)
{
  Preds tmp(other);
  swap(tmp);
  return *this;
}

void Preds::swap(Preds & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listident_, other.listident_);

}

Preds::~Preds()
{
  delete(listident_);

}

void Preds::accept(Visitor *v)
{
  v->visitPreds(this);
}

Preds *Preds::clone() const
{
  return new Preds(*this);
}



/********************   Pred    ********************/
Pred::Pred(Ident p1)
{
  ident_ = p1;

}

Pred::Pred(const Pred & other)
{
  ident_ = other.ident_;

}

Pred &Pred::operator=(const Pred & other)
{
  Pred tmp(other);
  swap(tmp);
  return *this;
}

void Pred::swap(Pred & other)
{
  std::swap(ident_, other.ident_);

}

Pred::~Pred()
{

}

void Pred::accept(Visitor *v)
{
  v->visitPred(this);
}

Pred *Pred::clone() const
{
  return new Pred(*this);
}




/********************   ListPredicate    ********************/

void ListPredicate::accept(Visitor *v)
{
  v->visitListPredicate(this);
}


ListPredicate *ListPredicate::clone() const
{
  return new ListPredicate(*this);
}


/********************   ListIdent    ********************/

void ListIdent::accept(Visitor *v)
{
  v->visitListIdent(this);
}


ListIdent *ListIdent::clone() const
{
  return new ListIdent(*this);
}


/********************   ListDecl    ********************/

void ListDecl::accept(Visitor *v)
{
  v->visitListDecl(this);
}


ListDecl *ListDecl::clone() const
{
  return new ListDecl(*this);
}




